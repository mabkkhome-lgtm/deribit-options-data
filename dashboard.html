<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Options Levels - Dynamic Bands</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #131722;
            color: #d1d4dc;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #1e222d;
            border-bottom: 1px solid #363a45;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 48px;
        }

        .logo {
            font-weight: 600;
            font-size: 15px;
        }

        .price-box {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .price {
            font-size: 22px;
            font-weight: 700;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #787b86;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #26a69a;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .toolbar {
            background: #1e222d;
            padding: 6px 12px;
            display: flex;
            gap: 4px;
            border-bottom: 1px solid #363a45;
        }

        .toolbar button {
            padding: 5px 12px;
            background: #2a2e39;
            border: 1px solid #363a45;
            color: #d1d4dc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .toolbar button:hover {
            background: #363a45;
        }

        .toolbar button.active {
            background: #2962ff;
            border-color: #2962ff;
        }

        #chart {
            flex: 1;
        }

        .sidebar {
            width: 280px;
            background: #1e222d;
            border-left: 1px solid #363a45;
            overflow-y: auto;
            font-size: 12px;
        }

        .panel {
            border-bottom: 1px solid #363a45;
            padding: 12px;
        }

        .panel-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            color: #787b86;
            margin-bottom: 10px;
        }

        .level {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            background: #2a2e39;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .level-label {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .dot.r {
            background: #2196f3;
        }

        .dot.s {
            background: #9c27b0;
        }

        .dot.c {
            background: #ffc107;
        }

        .level-value {
            font-weight: 600;
            font-family: 'Monaco', monospace;
            font-size: 11px;
        }

        .level-value.r {
            color: #2196f3;
        }

        .level-value.s {
            color: #9c27b0;
        }

        .level-value.c {
            color: #ffc107;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #2a2e39;
        }

        .stats-label {
            color: #787b86;
        }

        .stats-value {
            font-weight: 500;
        }

        .history-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 6px;
            background: #2a2e39;
            border-radius: 3px;
            margin-bottom: 3px;
            font-size: 10px;
        }

        .btn-refresh {
            background: #2962ff !important;
            border-color: #2962ff !important;
            margin-left: auto;
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="logo">ğŸ“Š Options Levels - Dynamic Bands</div>
        <div class="price-box">
            <span class="price" id="price">$---,---</span>
        </div>
        <div class="status">
            <span class="status-dot"></span>
            <span id="status">Connecting...</span>
        </div>
    </header>

    <div class="main">
        <div class="chart-area">
            <div class="toolbar">
                <button data-tf="1" class="active">1m</button>
                <button data-tf="5">5m</button>
                <button data-tf="15">15m</button>
                <button data-tf="60">1H</button>
                <button class="btn-refresh" id="btn-refresh">ğŸ”„ Calculate</button>
            </div>
            <div id="chart"></div>
        </div>

        <aside class="sidebar">
            <div class="panel">
                <div class="panel-title">ğŸ“Š Current Levels</div>
                <div class="level">
                    <div class="level-label">
                        <div class="dot r"></div> Resistance
                    </div>
                    <span class="level-value r" id="r-val">---</span>
                </div>
                <div class="level">
                    <div class="level-label">
                        <div class="dot c"></div> Price
                    </div>
                    <span class="level-value c" id="c-val">$---</span>
                </div>
                <div class="level">
                    <div class="level-label">
                        <div class="dot s"></div> Support
                    </div>
                    <span class="level-value s" id="s-val">---</span>
                </div>
            </div>

            <div class="panel">
                <div class="panel-title">ğŸ“ˆ Stats</div>
                <div class="stats-row"><span class="stats-label">Range</span><span class="stats-value"
                        id="stat-range">$---</span></div>
                <div class="stats-row"><span class="stats-label">Longs</span><span class="stats-value"
                        id="stat-longs">--</span></div>
                <div class="stats-row"><span class="stats-label">Shorts</span><span class="stats-value"
                        id="stat-shorts">--</span></div>
                <div class="stats-row"><span class="stats-label">Calcs</span><span class="stats-value"
                        id="stat-calcs">0</span></div>
            </div>

            <div class="panel">
                <div class="panel-title">ğŸ“œ Calculation History</div>
                <div class="history-list" id="history-list">
                    <div class="history-item"><span>Waiting...</span></div>
                </div>
            </div>
        </aside>
    </div>

    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const THALES_API = 'https://oss.thales-mfi.com/api/MarketScreener/FetchOptions';
        const CORS_PROXY = 'https://corsproxy.io/?';
        const UPDATE_INTERVAL = 60000; // 1 minute
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let chart, candleSeries, rSeries, sSeries;
        let currentPrice = 0;
        let timeframe = '1';
        let ws = null;
        
        // Store ALL calculations with timestamps (for building the smooth line)
        // Each entry: { timestamp: unix_seconds, r: resistance, s: support }
        let calculations = [];
        
        // Store candle data for reference
        let candleData = [];
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // THALES CALCULATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function getTomorrowExpiryCode() {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setUTCHours(0, 0, 0, 0);
            const epoch = new Date(0);
            return Math.floor((tomorrow - epoch) / (1000 * 60 * 60 * 24));
        }
        
        function parseCSV(csv, expiryCode) {
            const longs = [], shorts = [];
            for (const line of csv.trim().split('\n')) {
                const p = line.split(',');
                if (p.length < 7) continue;
                try {
                    if (parseInt(p[1]) !== expiryCode) continue;
                    const pos = {
                        type: p[0] === '0' ? 'call' : 'put',
                        strike: parseFloat(p[2]),
                        size: parseFloat(p[5]),
                        premium: parseFloat(p[6])
                    };
                    if (p[4] === '0') longs.push(pos);
                    else shorts.push(pos);
                } catch (e) {}
            }
            return { longs, shorts };
        }
        
        function calcPnL(positions, price, isBuyer) {
            let total = 0;
            for (const p of positions) {
                const intrinsic = p.type === 'call' ? Math.max(price - p.strike, 0) : Math.max(p.strike - price, 0);
                total += (isBuyer ? intrinsic - p.premium : p.premium - intrinsic) * p.size;
            }
            return total;
        }
        
        function findConvergence(longs, shorts) {
            const strikes = [...longs, ...shorts].map(p => p.strike);
            if (!strikes.length) return { r: 95000, s: 85000 };
            
            const min = Math.floor(Math.min(...strikes) * 0.9);
            const max = Math.ceil(Math.max(...strikes) * 1.1);
            const intersections = [];
            let prevDiff = null;
            
            for (let price = min; price < max; price += 10) {
                const diff = calcPnL(longs, price, true) - calcPnL(shorts, price, false);
                if (prevDiff !== null && prevDiff * diff < 0) intersections.push(price);
                prevDiff = diff;
            }
            
            if (intersections.length >= 2) return { s: intersections[0], r: intersections[intersections.length - 1] };
            if (intersections.length === 1) return { s: intersections[0], r: intersections[0] };
            const avg = strikes.reduce((a, b) => a + b, 0) / strikes.length;
            return { s: Math.round(avg * 0.95), r: Math.round(avg * 1.05) };
        }
        
        async function fetchAndCalculate() {
            document.getElementById('status').textContent = 'Calculating...';
            
            try {
                const now = new Date();
                const startOfDay = new Date(now); startOfDay.setUTCHours(0, 0, 0, 0);
                
                const url = `${CORS_PROXY}${THALES_API}?source=1&fromDate=${startOfDay.getTime()}&toDate=${now.getTime()}`;
                const res = await fetch(url);
                const csv = await res.text();
                
                const { longs, shorts } = parseCSV(csv, getTomorrowExpiryCode());
                document.getElementById('stat-longs').textContent = longs.length;
                document.getElementById('stat-shorts').textContent = shorts.length;
                
                if (!longs.length || !shorts.length) return;
                
                const { r, s } = findConvergence(longs, shorts);
                const timestamp = Math.floor(now.getTime() / 1000);
                
                // Add to calculations
                calculations.push({ timestamp, r, s });
                
                console.log(`âœ… ${now.toLocaleTimeString()} R=${r} S=${s}`);
                
                // Rebuild the smooth lines
                buildSmoothLines();
                updateUI(r, s);
                updateHistory();
                
                document.getElementById('stat-calcs').textContent = calculations.length;
                document.getElementById('status').textContent = 'Live';
                
            } catch (e) {
                console.error(e);
                document.getElementById('status').textContent = 'Error';
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SMOOTH LINE BUILDING
        // This interpolates R/S values for each candle to create smooth curves
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function buildSmoothLines() {
            if (calculations.length === 0 || candleData.length === 0) return;
            
            // Sort calculations by time
            calculations.sort((a, b) => a.timestamp - b.timestamp);
            
            const rLineData = [];
            const sLineData = [];
            
            for (const candle of candleData) {
                const candleTime = candle.time;
                
                // Find the R/S value for this candle time
                // Use the latest calculation that is <= this candle time
                let r = null, s = null;
                
                for (let i = calculations.length - 1; i >= 0; i--) {
                    if (calculations[i].timestamp <= candleTime) {
                        r = calculations[i].r;
                        s = calculations[i].s;
                        break;
                    }
                }
                
                // If no calculation before this candle, use the first one
                if (r === null && calculations.length > 0) {
                    r = calculations[0].r;
                    s = calculations[0].s;
                }
                
                if (r !== null) {
                    rLineData.push({ time: candleTime, value: r });
                    sLineData.push({ time: candleTime, value: s });
                }
            }
            
            // Also add current/future candles with latest calculation
            if (calculations.length > 0) {
                const latest = calculations[calculations.length - 1];
                const now = Math.floor(Date.now() / 1000);
                
                // Extend to current time if needed
                if (rLineData.length > 0 && rLineData[rLineData.length - 1].time < now) {
                    rLineData.push({ time: now, value: latest.r });
                    sLineData.push({ time: now, value: latest.s });
                }
            }
            
            rSeries.setData(rLineData);
            sSeries.setData(sLineData);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHART
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function initChart() {
            const container = document.getElementById('chart');
            
            chart = LightweightCharts.createChart(container, {
                layout: { background: { type: 'solid', color: '#131722' }, textColor: '#d1d4dc' },
                grid: { vertLines: { color: '#1e222d' }, horzLines: { color: '#1e222d' } },
                rightPriceScale: { borderColor: '#363a45' },
                timeScale: { borderColor: '#363a45', timeVisible: true },
                crosshair: { mode: 1 },
            });
            
            candleSeries = chart.addCandlestickSeries({
                upColor: '#26a69a', downColor: '#ef5350',
                borderUpColor: '#26a69a', borderDownColor: '#ef5350',
                wickUpColor: '#26a69a', wickDownColor: '#ef5350',
            });
            
            // SMOOTH CURVED LINES - like in the user's image
            rSeries = chart.addLineSeries({ 
                color: '#2196f3',  // Blue like in image
                lineWidth: 3, 
                title: 'R',
                priceLineVisible: true,
                lastValueVisible: true,
                crosshairMarkerVisible: true,
            });
            
            sSeries = chart.addLineSeries({ 
                color: '#9c27b0',  // Purple/maroon like in image
                lineWidth: 3, 
                title: 'S',
                priceLineVisible: true,
                lastValueVisible: true,
                crosshairMarkerVisible: true,
            });
            
            new ResizeObserver(() => {
                chart.applyOptions({ width: container.clientWidth, height: container.clientHeight });
            }).observe(container);
        }
        
        async function fetchCandles() {
            const interval = timeframe + 'm';
            const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=${interval}&limit=500`);
            const data = await res.json();
            
            candleData = data.map(d => ({
                time: d[0] / 1000,
                open: parseFloat(d[1]),
                high: parseFloat(d[2]),
                low: parseFloat(d[3]),
                close: parseFloat(d[4]),
            }));
            
            candleSeries.setData(candleData);
            chart.timeScale().fitContent();
            
            // Rebuild lines with new candle data
            buildSmoothLines();
        }
        
        function connectWS() {
            if (ws) ws.close();
            const interval = timeframe + 'm';
            ws = new WebSocket(`wss://stream.binance.com:9443/ws/btcusdt@kline_${interval}`);
            
            ws.onmessage = (e) => {
                const { k } = JSON.parse(e.data);
                currentPrice = parseFloat(k.c);
                const candleTime = k.t / 1000;
                
                candleSeries.update({
                    time: candleTime,
                    open: parseFloat(k.o),
                    high: parseFloat(k.h),
                    low: parseFloat(k.l),
                    close: parseFloat(k.c),
                });
                
                // Extend R/S lines to current candle
                if (calculations.length > 0) {
                    const latest = calculations[calculations.length - 1];
                    rSeries.update({ time: candleTime, value: latest.r });
                    sSeries.update({ time: candleTime, value: latest.s });
                }
                
                document.getElementById('price').textContent = '$' + currentPrice.toLocaleString('en-US', { maximumFractionDigits: 0 });
                document.getElementById('c-val').textContent = '$' + currentPrice.toLocaleString();
            };
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateUI(r, s) {
            document.getElementById('r-val').textContent = '$' + r.toLocaleString();
            document.getElementById('s-val').textContent = '$' + s.toLocaleString();
            document.getElementById('stat-range').textContent = '$' + (r - s).toLocaleString();
        }
        
        function updateHistory() {
            const container = document.getElementById('history-list');
            const reversed = [...calculations].reverse().slice(0, 20);
            container.innerHTML = reversed.map(d => {
                const time = new Date(d.timestamp * 1000).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                return `<div class="history-item">
                    <span style="color:#787b86">${time}</span>
                    <span style="color:#2196f3">R:${(d.r/1000).toFixed(1)}K</span>
                    <span style="color:#9c27b0">S:${(d.s/1000).toFixed(1)}K</span>
                </div>`;
            }).join('');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        document.querySelectorAll('[data-tf]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('[data-tf]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                timeframe = btn.dataset.tf;
                fetchCandles().then(connectWS);
            });
        });
        
        document.getElementById('btn-refresh').addEventListener('click', fetchAndCalculate);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        initChart();
        fetchCandles().then(() => {
            connectWS();
            fetchAndCalculate();
        });
        
        // Auto-calculate every minute
        setInterval(fetchAndCalculate, UPDATE_INTERVAL);
    </script>
</body>

</html>